
il y a 1 heure

Mettre à jour index.html
    ctx.arc(cx, cy, rayon, 0, Mathématiques.PI*2);
    ctx.style de trait = "#cbd5e1";
    ctx.largeur de ligne = 3;
    ctx.accident vasculaire cérébral();

    ctx.débutChemin();
    ctx.arc(cx, cy, 62, 0, Mathématiques.PI*2);
    ctx.fillStyle = #ffffff;
    ctx.remplir();
    ctx.style de trait = "#e2e8f0";
    ctx.largeur de ligne = 2;
    ctx.accident vasculaire cérébral();
  }

  fonction normaliserAngle(un){
    const twoPi = Mathématiques.PI * 2;
    retour ((un % twoPi) + twoPi) % twoPi;
  }
  fonction index du segment sélectionné(pourrir){
    const angle du pointeur = -Mathématiques.PI / 2;
    const un = normaliserAngle(angle du pointeur - pourrir);
    retour Mathématiques.sol(un / segAngle);
  }

  fonction définirRésultat(idx){
    const s = segments[idx];
    resTitre.contenu du texte = s.titre;
    resText.contenu du texte  = s.texte;

    si(s.pouce){
      pouceEl.source = s.pouce;
      pouceEl.style.afficher = "bloc";
      pouceEl.alt = "Visuel : " + s.titre;
    } autre {
      pouceEl.style.afficher = "aucun";
      pouceEl.source = "";
    }

    si(s.note){
      bouton openMemo.style.afficher = "flexible en ligne";
      openMemoLink.style.afficher = "flexible en ligne";
      openMemoLink.href = s.note;
      bouton openMemo.clic = () => openModal(s.titre de la note || "Fiche mémo", s.note);
    } autre {
      bouton openMemo.style.afficher = "aucun";
      openMemoLink.style.afficher = "aucun";
      openMemoLink.href = "#";
      bouton openMemo.clic = nul;
    }
  }

  fonction openModal(titre, source){
    modalTitre.contenu du texte = titre;
    modalFrame.source = source;
    modal.liste de classes.ajouter("ouvrir");
    document.corps.style.débordement = "caché";
  }
  fonction fermerModal(){
    modal.liste de classes.retirer("ouvrir");
    modalFrame.source = "";
    document.corps.style.débordement = "";
  }
  modalFermer.ajouterEventListener("clic", fermerModal);
  modal.ajouterEventListener("clic", (e) => { si(e.cible === modal) fermerModal(); });
  fenêtre.ajouterEventListener("touche enfoncée", (e) => { si(e.clé === "S'échapper") fermerModal(); });

  fonction rotation(){
    si(filage) retour;
    filage = vrai;
    bouton de démarrage.désactivé = vrai;

    const tours supplémentaires = 5 + Mathématiques.aléatoire() * 3;
    const index cible = Mathématiques.sol(Mathématiques.aléatoire() * segments.longueur);

    const angle du pointeur = -Mathématiques.PI / 2;
    const eps = segAngle * 0,5;
    const Angle de roue souhaité = index cible * segAngle + eps;

    laisser rotFinal = angle du pointeur - Angle de roue souhaité;
    rotFinal -= tours supplémentaires * Mathématiques.PI * 2;

    const rotStart = rotation;
    const rotEnd = rotFinal;

    const durée = 2200 + Mathématiques.aléatoire() * 800;
    const t0 = performance.maintenant();

    fonction easeOutCubic(t){ retour 1 - Mathématiques.pouvoir(1 - t, 3); }

    fonction cadre(maintenant){
      const t = Mathématiques.min(1, (maintenant - t0) / durée);
      const e = easeOutCubic(t);
      rotation = rotStart + (rotEnd - rotStart) * e;
      roue de tirage(rotation);

      si(t < 1){
        requestAnimationFrame(cadre);
      } autre {
        filage = FAUX;
        bouton de démarrage.désactivé = FAUX;
        définirRésultat(index du segment sélectionné(rotation));
      }
    }
    requestAnimationFrame(cadre);
  }

  roue de tirage(rotation);
  bouton de démarrage.ajouterEventListener("clic", rotation);
  toile.ajouterEventListener("clic", rotation);
</scénario>

</corps>
</HTML>


il y a 1 heure

Mettre à jour index.html






